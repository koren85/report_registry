class IssuesController < ApplicationController
  before_action :find_project
  before_action :authorize, except: [:index]

  helper :sort
  include SortHelper

  def index
    @issues = @project.issues.open
    render json: @issues.select(:id, :subject)
  end

  def available_assignees
    @project = Project.find(params[:project_id])
    role_id = Setting.plugin_report_registry['assignee_role_id']

    users = @project.users_by_role[Role.find(role_id)].to_a

    render json: users.map { |u| { id: u.id, name: u.name } }
  end

  # Метод для получения данных таблицы с сортировкой
  def table_data
    sort_init 'id', 'asc'
    sort_update %w(id subject status_id fixed_version_id start_date due_date parent_id)

    @issues = @project.issues
                      .includes(:status, :fixed_version, :parent)
                      .order(sort_clause)

    issues_data = @issues.map do |issue|
      {
        id: issue.id,
        subject: issue.subject,
        status: issue.status.try(:name),
        version: issue.fixed_version.try(:name),
        start_date: issue.start_date,
        due_date: issue.due_date,
        parent_issue: issue.parent.try(:subject),
        subtask: issue.custom_field_value(Setting.plugin_report_registry['subtask_field_id'])
      }
    end

    render json: issues_data
  end

  # Получение списка доступных статусов для новой задачи
  def statuses
    statuses = IssueStatus.sorted.map { |s| { id: s.id, name: s.name } }
    render json: statuses
  end

  # Создание новой задачи
  def create
    @project = Project.find(params[:project_id])
    @issue = Issue.new(issue_params)
    @issue.project = @project
    @issue.author = User.current
    @issue.tracker_id = Setting.plugin_report_registry['default_tracker_id']
    @issue.status_id = Setting.plugin_report_registry['default_status_id']

    if @issue.save
      render json: {
        success: true,
        issue: {
          id: @issue.id,
          subject: @issue.subject,
          status: @issue.status.try(:name),
          version: @issue.fixed_version.try(:name),
          start_date: @issue.start_date,
          due_date: @issue.due_date,
          assigned_to: @issue.assigned_to.try(:name)
        }
      }
    else
      render json: { success: false, errors: @issue.errors.full_messages }, status: :unprocessable_entity
    end
  end

  def available_statuses
    statuses = IssueStatus.all.map { |status| { id: status.id, name: status.name } }
    render json: statuses
  end

  private

  def sort_column
    %w[id subject status_id fixed_version_id start_date due_date parent_id].include?(params[:sort]) ? params[:sort] : 'id'
  end

  def sort_direction
    %w[asc desc].include?(params[:direction]) ? params[:direction] : 'asc'
  end

  def find_project
    @project = Project.find(params[:project_id])
  rescue ActiveRecord::RecordNotFound
    render_404
  end

  def issue_params
    params.require(:issue).permit(:subject, :assigned_to_id, :fixed_version_id,
                                  :start_date, :due_date)
  end
end
